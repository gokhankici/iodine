import collections
import json
import networkx    as nx
import subprocess
import sys

import pdb

def debug(*args, **kwargs):
    kwargs["file"] = sys.stderr
    # print(*args, **kwargs)
    pass

def export_to_dot(g):
    return nx.nx_pydot.to_pydot(g)

def print_graph(g):
    print(export_to_dot(g))

def dist_from_sources(g, sources):
    dist     = {v:0 for v in sources}
    worklist = collections.deque()
    worklist.extend(sources)
    while worklist:
        v = worklist.popleft()
        d = dist[v]
        for u in g.successors(v):
            if u not in dist:
                dist[u] = d + 1
                worklist.append(u)
    return dist

def parse_cplex_input(filename):
    """
    Parse the cplex input file generated by Iodine.
    """
    def to_edge(l):
        if len(l) == 2:
            return (l[0], l[1])
        elif len(l) == 3:
            return (l[0], l[1], dict(type=l[2]))
        else:
            print("illegal edge: {}".format(l))
            sys.exit(1)

    with open(filename, 'r') as f:
        data = json.load(f)

    edges          = [ to_edge(l) for l in data["edges"] if l[0] != l[1] ]
    must_eq        = data["must_eq"]
    names          = { l[0] : l[1][0] for l in data["mapping"] }
    inv_name       = { l[1][0] : l[0] for l in data["mapping"] }
    is_reg         = { l[0] : l[1][1] for l in data["mapping"] }
    cannot_mark_eq = [ inv_name[v] for v in data["cannot_mark_eq"] ]

    g = nx.MultiDiGraph()
    g.add_edges_from(edges)

    return { "graph"          : g,
             "must_eq"        : must_eq,
             "cannot_mark_eq" : cannot_mark_eq,
             "names"          : names,
             "is_reg"         : is_reg,
             "inv_names"      : inv_name }

def visualize_graph():
    """
    Run graphviz on graph.dot.
    """
    rc = subprocess.run(["dot", "-Tpdf", "graph.dot", "-o", "graph.pdf"])
    if rc.returncode != 0:
        print("error while running dot")
        sys.exit(1)

def write_dot_file(g, names):
    """
    Create the graph.dot to be printed by graphviz.
    Names are a mapping from node ids to node names.
    """
    g2 = nx.relabel_nodes(g, names, copy=True)
    with open("graph.dot", "w") as f:
        f.write(export_to_dot(g2).to_string())

def components(g, names, **kwargs):
    """
    Print the graph using dot, but replace components with a single node.
    """
    g2 = nx.DiGraph()
    cmap = {}

    for c in nx.strongly_connected_components(g):
        l = list(c)
        cmap[l[0]] = l

    def any_edge(us, vs):
        for u in us:
            for v in vs:
                if g.has_edge(u,v):
                    yield (u, v)

    names2 = names.copy()

    for u,lu in cmap.items():
        for v,lv in cmap.items():
            es = list(any_edge(lu, lv))
            if es:
                g2.add_edge(u, v)
                labels = []
                for u2, v2 in es:
                    eds = g.get_edge_data(u2, v2)
                    if eds:
                        for k, d in eds.items():
                            if "label" in d:
                                labels.append(d["label"])
                g2.edges[u,v]["label"] = sum(labels)

        if len(lu) > 1:
            names2[u] = "cycle-{}".format(len(lu))

    visualize = True if "visualize" not in kwargs else kwargs["visualize"]
    if visualize:
        write_dot_file(g2, names2)
        visualize_graph()

def dict_to_list(d, default=0, size=None):
    """
    Converts the given dictionary of type (Map Int a) to [a].
    """
    if size is None:
        size = max(d.keys(), default=-1) + 1
    l = [default] * size

    for i, v in d.items():
        assert(type(i) == int)
        l[i] = v
    return l

def sep():
    print("-" * 120)

def val_to_int(v):
    """
    Converts a double value calculated by the ILP solver into an integer.
    """
    r = round(v)
    if r - v > 1e-6:
        print("value {} is not a floating point very close to an integer!".format(v),
              file=sys.stderr)
        sys.exit(1)
    return int(r)
